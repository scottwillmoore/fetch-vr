//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.Moveit
{
    [Serializable]
    public class AttachedCollisionObjectMsg : Message
    {
        public const string k_RosMessageName = "moveit_msgs/AttachedCollisionObject";
        public override string RosMessageName => k_RosMessageName;

        //  The CollisionObject will be attached with a fixed joint to this link
        public string link_name;
        // This contains the actual shapes and poses for the CollisionObject
        // to be attached to the link
        // If action is remove and no object.id is set, all objects
        // attached to the link indicated by link_name will be removed
        public CollisionObjectMsg @object;
        //  The set of links that the attached objects are allowed to touch
        //  by default - the link_name is already considered by default
        public string[] touch_links;
        //  If certain links were placed in a particular posture for this object to remain attached 
        //  (e.g., an end effector closing around an object), the posture necessary for releasing
        //  the object is stored here
        public Trajectory.JointTrajectoryMsg detach_posture;
        //  The weight of the attached object, if known
        public double weight;

        public AttachedCollisionObjectMsg()
        {
            this.link_name = "";
            this.@object = new CollisionObjectMsg();
            this.touch_links = new string[0];
            this.detach_posture = new Trajectory.JointTrajectoryMsg();
            this.weight = 0.0;
        }

        public AttachedCollisionObjectMsg(string link_name, CollisionObjectMsg @object, string[] touch_links, Trajectory.JointTrajectoryMsg detach_posture, double weight)
        {
            this.link_name = link_name;
            this.@object = @object;
            this.touch_links = touch_links;
            this.detach_posture = detach_posture;
            this.weight = weight;
        }

        public static AttachedCollisionObjectMsg Deserialize(MessageDeserializer deserializer) => new AttachedCollisionObjectMsg(deserializer);

        private AttachedCollisionObjectMsg(MessageDeserializer deserializer)
        {
            deserializer.Read(out this.link_name);
            this.@object = CollisionObjectMsg.Deserialize(deserializer);
            deserializer.Read(out this.touch_links, deserializer.ReadLength());
            this.detach_posture = Trajectory.JointTrajectoryMsg.Deserialize(deserializer);
            deserializer.Read(out this.weight);
        }

        public override void SerializeTo(MessageSerializer serializer)
        {
            serializer.Write(this.link_name);
            serializer.Write(this.@object);
            serializer.WriteLength(this.touch_links);
            serializer.Write(this.touch_links);
            serializer.Write(this.detach_posture);
            serializer.Write(this.weight);
        }

        public override string ToString()
        {
            return "AttachedCollisionObjectMsg: " +
            "\nlink_name: " + link_name.ToString() +
            "\n@object: " + @object.ToString() +
            "\ntouch_links: " + System.String.Join(", ", touch_links.ToList()) +
            "\ndetach_posture: " + detach_posture.ToString() +
            "\nweight: " + weight.ToString();
        }

#if UNITY_EDITOR
        [UnityEditor.InitializeOnLoadMethod]
#else
        [UnityEngine.RuntimeInitializeOnLoadMethod]
#endif
        public static void Register()
        {
            MessageRegistry.Register(k_RosMessageName, Deserialize);
        }
    }
}
